#include <msp430fr2355.h>
#include "LiquidCrystal_I2C.h"
#include <stdio.h>
#include <string.h>

volatile char input_buffer[8];
volatile char save_buffer[8];
volatile unsigned int input_index = 0;
volatile unsigned int uart_idle_time = 0;

void init_1(void) {
    // Configure GPIO for UART (P1.6 = RXD, P1.7 = TXD)
    P1SEL0 |= BIT6 | BIT7;      // Primary function for UART
    P1SEL1 &= ~(BIT6 | BIT7);   // Ensure secondary function bits are cleared
    UCA0CTLW0 |= UCSWRST;       // Put eUSCI_A0 in reset state
    UCA0CTLW0 |= UCSSEL_2;      // Configure eUSCI_A0 for UART mode, SMCLK
    //Baud rate = 9600 // 1 MHz / 9600 = ~104.167 → use 104
    UCA0BR0 = 104;
    UCA0BR1 = 0;
    UCA0MCTLW = 0x1100;         // UCBRSx = 1, UCBRFx = 0, OS16 = 1
    //Timer for Interrupts
    TA1CCTL0 = CCIE;            // Enable interrupt for CCR0
    TA1CCR0 = 1000 - 1;         // 1000 clock ticks = 1 ms (assuming SMCLK = 1 MHz)
    TA1CTL = TASSEL_2 | MC_1 | TACLR; // SMCLK, up mode, clear TAR
    //Setup
    PM5CTL0 &= ~LOCKLPM5;
    UCA0CTLW0 &= ~UCSWRST;      // Release from reset
    //Interrupts
    UCA0IE |= UCRXIE;         // Enable UART receive interrupt
    __enable_interrupt();     // Enable global interrupts
    //State Pin
    P4DIR &= ~BIT6;
    P4REN |= BIT6;
    P4OUT |= BIT6;
}

void setup_1(void){
    //PWM setup
    P6DIR |= BIT1;               // P6.1 output
    P6SEL0 |= BIT1;              // P6.1  options select (TB3.2)
    // Configure Timer3_B for PWM
    TB3CCR0 = 100;               // PWM period (100 = 100%)
    TB3CCTL2 = OUTMOD_7;         // Reset/set mode
    TB3CCR2 = 0;          // Start with 0% duty cycle
    TB3CTL = TBSSEL__SMCLK | MC__UP | TBCLR;  // SMCLK, Up mode, clear timer
    //LED Display
    I2C_Init(0x27);
    LCD_Setup();
    LCD_ClearDisplay();         // Clear entire display
    LCD_SetCursor(0, 0);        // Set cursor to column 0, row 0
    LCD_Write("No Signal");     // Write message on first line
}

unsigned int Update_Buffer(void) {
    int value = 0;
    int valid = 1;

    // Check if input_buffer is all digits and convert
    for (int i = 0; input_buffer[i] != '\0'; i++) {
        if (input_buffer[i] < '0' || input_buffer[i] > '9') {
            valid = 0;
            break;
        }
        value = value * 10 + (input_buffer[i] - '0');
    }

    if (valid) {
        if (value > 100) value = 100;

        // Valid input: update save_buffer
        strncpy(save_buffer, input_buffer, sizeof(save_buffer) - 1);
        save_buffer[sizeof(save_buffer) - 1] = '\0';

        return (unsigned int)value;
    } else {
        // Invalid input: parse save_buffer to int and return that
        int old_value = 0;
        for (int i = 0; save_buffer[i] != '\0'; i++) {
            if (save_buffer[i] < '0' || save_buffer[i] > '9') {
                // If save_buffer corrupted or invalid, just return 0
                return 0;
            }
            old_value = old_value * 10 + (save_buffer[i] - '0');
        }
        if (old_value > 100) old_value = 100;
        return (unsigned int)old_value;
    }
}

int main(void) {
    WDTCTL = WDTPW | WDTHOLD;   // Stop WDT
    init_1();
    while(1){
        setup_1();
        unsigned int pwm_duty = 0;  // Initial PWM to 0
        while (P4IN & BIT6) {
            __bis_SR_register(LPM0_bits + GIE);
            if (strcmp((char*)input_buffer, (char*)save_buffer) != 0) {
                pwm_duty = Update_Buffer();
                LCD_ClearDisplay();
                LCD_SetCursor(0, 0);
                LCD_Write("Speed:");

                char Nbuffer[4];
                sprintf(Nbuffer, "%d", pwm_duty);
                LCD_Write(Nbuffer);

                LCD_Write("%");
                TB3CCR2 = (pwm_duty * 655) / 100;; // Scale to match 0–655
            }
        }
        __delay_cycles(10000);
    }
}

#pragma vector=USCI_A0_VECTOR
__interrupt void USCI_A0_ISR(void) {
    if (UCA0IFG & UCRXIFG) {
        char rx = UCA0RXBUF;

        if (input_index < 8 - 1) {
            input_buffer[input_index++] = rx;
            uart_idle_time = 0;
        }
        UCA0IFG &= ~UCRXIFG;
    }
}

#pragma vector=TIMER1_A0_VECTOR
__interrupt void Timer1_A0_ISR(void) {
    if (input_index > 0) {
        uart_idle_time++;
        if (uart_idle_time >= 100) { // 100ms no signal
            input_buffer[input_index] = '\0';
            input_index = 0;
            uart_idle_time = 0;
            __bic_SR_register_on_exit(LPM0_bits);
        }
    }
}
